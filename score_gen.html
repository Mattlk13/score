<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>Score Generation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Score</span> <span class="project-version">0.4.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="basics.html"><div class="inner"><span>Basics of Score Writing Using Lists </span></div></a></li><li class="depth-1 "><a href="csound.html"><div class="inner"><span>Csound Live Coding Example </span></div></a></li><li class="depth-1 "><a href="design.html"><div class="inner"><span>Design</span></div></a></li><li class="depth-1 "><a href="euclid.html"><div class="inner"><span>Euclidean Rhythms</span></div></a></li><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to Score</span></div></a></li><li class="depth-1 "><a href="lc.html"><div class="inner"><span>lc! - mini-language for notation</span></div></a></li><li class="depth-1 "><a href="mask.html"><div class="inner"><span>Mask</span></div></a></li><li class="depth-1 "><a href="musical_values.html"><div class="inner"><span>Musical Values</span></div></a></li><li class="depth-1  current"><a href="score_gen.html"><div class="inner"><span>Score Generation</span></div></a></li><li class="depth-1 "><a href="score_mapping.html"><div class="inner"><span>Score Mapping </span></div></a></li><li class="depth-1 "><a href="score_organization.html"><div class="inner"><span>Score Organization </span></div></a></li><li class="depth-1 "><a href="sieves.html"><div class="inner"><span>Sieves</span></div></a></li><li class="depth-1 "><a href="transformation.html"><div class="inner"><span>Score Transformation </span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>score</span></div></div></li><li class="depth-2 branch"><a href="score.amp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>amp</span></div></a></li><li class="depth-2 branch"><a href="score.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="score.euclid.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>euclid</span></div></a></li><li class="depth-2 branch"><a href="score.freq.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>freq</span></div></a></li><li class="depth-2 branch"><a href="score.lc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lc</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mask</span></div></div></li><li class="depth-3 branch"><a href="score.mask.accumulator.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>accumulator</span></div></a></li><li class="depth-3 branch"><a href="score.mask.bpf.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bpf</span></div></a></li><li class="depth-3 branch"><a href="score.mask.generators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generators</span></div></a></li><li class="depth-3 branch"><a href="score.mask.items.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>items</span></div></a></li><li class="depth-3 branch"><a href="score.mask.mask.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mask</span></div></a></li><li class="depth-3 branch"><a href="score.mask.oscillators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>oscillators</span></div></a></li><li class="depth-3 branch"><a href="score.mask.probability.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>probability</span></div></a></li><li class="depth-3"><a href="score.mask.quantizer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>quantizer</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -269px;"><span class="top" style="height: 278px;"></span><span class="bottom"></span></span><span>orchestra</span></div></div></li><li class="depth-3 branch"><a href="score.orchestra.performer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>performer</span></div></a></li><li class="depth-3"><a href="score.orchestra.performer-group.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>performer-group</span></div></a></li><li class="depth-2 branch"><a href="score.sieves.html"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>sieves</span></div></a></li><li class="depth-2 branch"><a href="score.tuning.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tuning</span></div></a></li><li class="depth-2"><a href="score.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#score-generation" name="score-generation"></a>Score Generation</h1>
<p>Score includes two primary ways for generating note lists: <code>gen-notes</code> and <code>gen-notes2</code>. The first is based on Clojure sequences and is modeled on SC3’s Pattern Library. The latter uses higher-order programming and time-based generator functions and is modeled on CMask.</p>
<h2><a href="#gen-notes" name="gen-notes"></a>gen-notes</h2>
<p>Score’s primary tool for generating notes is the <code>gen-notes</code> function:</p>
<pre><code class="clojure">(defn- score-arg  [a]
  (cond (sequential? a) a 
    (fn? a) (repeatedly a)
    :default (repeat a)))

(defn gen-notes 
  "Generate notes by assembling sequences together into notes. 
  If a constant value is given, it will be wrapped with (repeat).
  If a no-arg function is given, it will be wrapped with (repeatedly)."
  [&amp; fields]
  (let [pfields  (map score-arg fields)]
    (apply map (fn [&amp; a] (into [] a)) pfields)))
</code></pre>
<p>Given a set of fields — which may be sequences, functions, or values — <code>gen-notes</code> will generate a list of notes, where the value of each note is generated using the value from each field. If the field is a sequence, each item of the sequence will be used. If the field is a function, it will be wrapped into a sequence using Clojure’s <code>repeatedly</code> function. Finally, if a single value is given, an infinite list comprised of that value is created using the <code>repeat</code> function.</p>
<p>Because <code>gen-notes</code> uses <code>map</code>, the returned value is a lazy sequence. If all fields given to <code>gen-notes</code> are infinite sequence, then the resulting sequence is also infinite. If any of the fields are finite sequences, then the resulting sequence of notes will have a length equal to the shortest field sequence. The user should use the same care when using <code>gen-notes</code> as they would with regular Clojure sequences in regards to infinite sequence generation.</p>
<h3><a href="#example" name="example"></a>Example</h3>
<p>The following example:</p>
<pre><code class="clojure">(gen-notes 1 (range) 1.0 [1 2 3 4 5] (range 6 300))
</code></pre>
<p>When evaluated will generate the following list of lists:</p>
<pre><code class="clojure">([1 0 1.0 1 6] 
 [1 1 1.0 2 7] 
 [1 2 1.0 3 8] 
 [1 3 1.0 4 9] 
 [1 4 1.0 5 10])                                                                              
</code></pre>
<p>In the call to gen-notes, the first and third argument are constants, 1 and 1.0. These values are repeated for each generated note. For the sequences used in the 2nd, 4th, and 5th fields, the first value from each sequence is used for the first generated note, then the next values used for the second note, and so on. As the 4th field is a finite list with the shortest number of elements, only five notes will be generated.</p>
<h2><a href="#gen-notes2-and-score-mask" name="gen-notes2-and-score-mask"></a>gen-notes2 and score.mask</h2>
<p>Score offers an alternate model for generating notes, <code>gen-notes2</code>, based on time-based generator functions:</p>
<pre><code class="clojure">    (defn- const
      "Returns a function that generates a constant value."
      [val]
      (fn [t]
        val))

    (defn seq-&gt;gen
      "Converts a sequence into a generator function with time argument."
      [vs]
      (let [curval (atom vs)]
        (fn [t]
          (let [[a &amp; b] @curval]
            (swap! curval rest)
            a
            ))))

    (defn wrap-generator
      "Utility function to convert argument into a generator function
      if not so already."
      [f]
      (cond
        (seq? f) (seq-&gt;gen f)
        (fn? f) f
        :else (const f)))

    (defn gen-notes2
      "Generate notes with time-based generator functions. This score
      generation method is based on CMask. Given fields should be
      single-arg functions that generate a value based on time argument."
      [start dur &amp; fields]
      (let [gens (map wrap-generator fields)
            [instrfn startfn &amp; r] gens
            dur (double dur)
            start (double start)]
        (loop [cur-start 0.0
               retval []]
          (if (&lt; cur-start dur)
            (let [i (instrfn cur-start)
                  ^double xt (startfn cur-start)
                  note (into [i (+ start cur-start)]
                         (map (fn [a] (a cur-start)) r))]
              (recur (+ cur-start xt) (conj retval note)))
            retval))))
</code></pre>
<p>Given an initial start time, duration, and set of fields — which may be sequences, functions, or values — <code>gen-notes2</code> will generate a list of notes, where the values of each note is generated using the values from each field. Unlike <code>gen-notes</code>, fields in <code>gen-notes2</code> are single-argument generator functions that take in a time value. If the field is a sequence, <code>seq-&amp;gt;gen</code> will be called to convert the sequence into a generator function. If the field is a function, it is assumed to already be a generator function and used as-is. Finally, if a single value is given, an infinite generator function is produced using the <code>const</code> function.</p>
<p><code>gen-notes2</code> is modeled on CMask’s processing model, where <code>gen-notes2</code> maps to CMask’s <em>fields</em>, and field arguments to <code>gen-notes2</code> map to CMask’s <em>parameters</em>. For each note, all fields will be called given the current start time value (<code>cur-start</code>). The value generated by the second field’s value will be especially used to increment <code>cur-start</code> for the next note generated. Generation of notes will continue until the <code>cur-start</code> value is greater than or equal to the <code>dur</code> argument.</p>
<p>All of CMask’s parameters — oscillators, items, probabilities, and break-point functions — have been implemented as generator functions packaged in sub-namespaces of the primary <code>score.mask</code> namespace. Additionally, CMask’s masks, quantisers, and accumulators have also been implemented as generator functions that decorate other generator functions. The generator functions provided by <code>score.mask</code>, together with <code>gen-notes2</code>, provide a complete implementation of CMask’s capabilities within Score.</p>
<p>As with <code>gen-notes</code>, the user should take special care of using infinite generator functions. This is especially important as <code>gen-notes2</code> eagerly generates the resulting note list. If a finite generator function is not provided, calling <code>gen-notes2</code> will result in an infinite loop.</p>
<h3><a href="#example" name="example"></a>Example</h3>
<pre><code class="clojure">user=&gt; (gen-notes2 0.0 4.0
              4 0.5 3
              (rand-range 0.1 20)
              (item-cycle [1 2 3])
              (swing [8 9 10])
              (heap [10 100 400])
              (rand-item [50 500 5000]))
[[4 0.0 3 0.5357457756267113 1 8 400 5000]
 [4 0.5 3 16.091049682038065 2 9 10 500]
 [4 1.0 3 5.7949011228034 3 10 100 50]
 [4 1.5 3 14.749602188427321 1 9 10 50]
 [4 2.0 3 14.01972320806139 2 8 100 500]
 [4 2.5 3 10.87719434050349 3 9 400 500]
 [4 3.0 3 17.53310173768086 1 10 400 5000]
 [4 3.5 3 4.218225062429189 2 9 10 500]]
</code></pre>
<p>The above shows an example usage of <code>gen-notes2</code> and its results. The first two arguments are the initial start time (0.0) and duration (4.0). The next 3 values are constants. Note that while the second field always returns 0.5, the generated value in the note list is the <code>cur-start</code> value calculated in the loop. The 4th through 8th fields are all time-based generator functions created by calling <code>score.mask</code> functions. For each of these fields, calling the <code>score.mask</code> function returns another function that takes in a time argument. This is shown in the implementation of <code>rand-item</code>: </p>
<pre><code class="clojure">(defn rand-item
  "Generates values as random permutations of a sequence"
  [vs]
  (fn [t] 
    (rand-nth vs)))
</code></pre>
<p>The anonymous function returned by <code>rand-item</code> has a single argument <code>t</code>. In this case, the <code>t</code> argument is not used. Instead, the <code>vs</code> argument, which is closed over by the anonymous function, is used. While generator functions for use with <code>gen-notes2</code> must take in a single time argument, they are not required to use it.</p></div></div></div></body></html>